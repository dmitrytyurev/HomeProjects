1
00:00:00,000 --> 00:00:02,100
- Right now some nation states

2
00:00:02,100 --> 00:00:06,120
and individual actors are
intercepting and storing lots

3
00:00:06,120 --> 00:00:09,540
of encrypted data like
passwords, bank details,

4
00:00:09,540 --> 00:00:11,356
and social security numbers.

5
00:00:11,356 --> 00:00:13,380
But they can't open these files.

6
00:00:13,380 --> 00:00:15,510
So why are they doing it?

7
00:00:15,510 --> 00:00:16,890
Well, because they believe that within

8
00:00:16,890 --> 00:00:18,480
the next 10 to 20 years,

9
00:00:18,480 --> 00:00:20,370
they will have access
to a quantum computer

10
00:00:20,370 --> 00:00:23,013
that can break the encryption in minutes.

11
00:00:23,850 --> 00:00:25,230
This procedure is known

12
00:00:25,230 --> 00:00:29,910
as Store Now, Decrypt Later or SNDL.

13
00:00:29,910 --> 00:00:32,610
And it works because there
is information around today

14
00:00:32,610 --> 00:00:34,860
that will still be valuable in a decade.

15
00:00:34,860 --> 00:00:37,590
Things like industrial and
pharmaceutical research

16
00:00:37,590 --> 00:00:39,961
and top secret government intelligence,

17
00:00:39,961 --> 00:00:42,720
and everyone is aware of this threat.

18
00:00:42,720 --> 00:00:44,400
The National Security Administration

19
00:00:44,400 --> 00:00:46,777
says that a sufficiently
large quantum computer,

20
00:00:46,777 --> 00:00:49,410
if built would be capable of undermining

21
00:00:49,410 --> 00:00:52,530
all widely deployed public key algorithms.

22
00:00:52,530 --> 00:00:54,780
- You know in a five to 10 year timeframe,

23
00:00:54,780 --> 00:00:58,114
quantum computing will break
encryption as we know it today.

24
00:00:58,114 --> 00:01:00,600
- Even though sufficiently
powerful quantum computers

25
00:01:00,600 --> 00:01:02,220
are still years away,

26
00:01:02,220 --> 00:01:05,940
they're already a threat because
of Store Now Decrypt Later,

27
00:01:05,940 --> 00:01:08,790
which is why the US Congress
just passed legislation

28
00:01:08,790 --> 00:01:11,157
mandating all agencies start transitioning

29
00:01:11,157 --> 00:01:13,830
right now to new methods of cryptography

30
00:01:13,830 --> 00:01:16,413
that can't be broken by quantum computers.

31
00:01:17,730 --> 00:01:19,410
You know, our current encryption schemes

32
00:01:19,410 --> 00:01:20,747
have been remarkably successful

33
00:01:20,747 --> 00:01:23,806
working effectively for over 40 years.

34
00:01:23,806 --> 00:01:27,060
Up until the 1970s, if
you wanted to exchange

35
00:01:27,060 --> 00:01:28,920
private information with someone,

36
00:01:28,920 --> 00:01:31,320
you would first have to meet up in person

37
00:01:31,320 --> 00:01:33,330
and share a secret key.

38
00:01:33,330 --> 00:01:37,950
This same key would be used to
encrypt and decrypt messages.

39
00:01:37,950 --> 00:01:41,120
So it's known as a
symmetric key algorithm.

40
00:01:41,120 --> 00:01:43,770
As long as no one else gets
their hands on the key,

41
00:01:43,770 --> 00:01:46,260
your messages are safe.

42
00:01:46,260 --> 00:01:48,450
But now what if you wanna send information

43
00:01:48,450 --> 00:01:49,770
to someone you've never met,

44
00:01:49,770 --> 00:01:53,010
and it's too hard to arrange
an in-person meeting.

45
00:01:53,010 --> 00:01:56,190
You can't share a key
over an unsecured channel

46
00:01:56,190 --> 00:01:58,170
like a phone line or the mail,

47
00:01:58,170 --> 00:02:00,840
because it could be intercepted.

48
00:02:00,840 --> 00:02:04,500
And this is what in 1977,
led three scientists,

49
00:02:04,500 --> 00:02:06,570
Riverst, Shamir, and Adelman

50
00:02:06,570 --> 00:02:09,180
to come up with an
encryption breakthrough.

51
00:02:09,180 --> 00:02:12,240
Today it's known by their initials RSA,

52
00:02:12,240 --> 00:02:14,790
and it works something like this.

53
00:02:14,790 --> 00:02:17,790
Every person has two
really big prime numbers,

54
00:02:17,790 --> 00:02:20,520
all their own which they keep secret.

55
00:02:20,520 --> 00:02:22,380
They multiply these numbers together

56
00:02:22,380 --> 00:02:24,240
to get an even bigger number,

57
00:02:24,240 --> 00:02:27,420
which they make public
for everyone to see.

58
00:02:27,420 --> 00:02:30,058
Now, if I wanna send
someone a private message,

59
00:02:30,058 --> 00:02:34,500
I use their big public number to garble my message.

60
00:02:34,500 --> 00:02:37,500
And I garble it in such a
way that it is impossible

61
00:02:37,500 --> 00:02:41,190
to ungarble without knowing
the two prime factors

62
00:02:41,190 --> 00:02:42,720
that made that number.

63
00:02:42,720 --> 00:02:44,880
This is an asymmetric key system,

64
00:02:44,880 --> 00:02:47,460
since different keys are used to encrypt

65
00:02:47,460 --> 00:02:49,440
and decrypt the message.

66
00:02:49,440 --> 00:02:53,010
So it's easy for my intended
recipient to decode,

67
00:02:53,010 --> 00:02:55,258
but impossible for everyone else,

68
00:02:55,258 --> 00:02:59,820
unless they can factor
that large public number.

69
00:02:59,820 --> 00:03:02,550
Now, someone could try to factor
it, using a supercomputer,

70
00:03:02,550 --> 00:03:04,260
in the best known factoring algorithm

71
00:03:04,260 --> 00:03:07,560
the General Number Field
Sieve, but modern cryptography

72
00:03:07,560 --> 00:03:11,670
uses prime numbers that
are around 313 digits long.

73
00:03:11,670 --> 00:03:13,980
Factoring a product of
two primes this big,

74
00:03:13,980 --> 00:03:15,270
even with a supercomputer,

75
00:03:15,270 --> 00:03:17,923
would take around 16 million years,

76
00:03:17,923 --> 00:03:21,540
but not on a quantum computer.

77
00:03:21,540 --> 00:03:23,730
See, in normal computers, a bit can only

78
00:03:23,730 --> 00:03:27,481
be in one state at a time,
either a zero or a one.

79
00:03:27,481 --> 00:03:29,820
So if you had two bits, they could be

80
00:03:29,820 --> 00:03:33,453
in one of four possible
states, 00, 01, 10 or 11.

81
00:03:36,240 --> 00:03:38,730
Let's say each of these
states represents a number,

82
00:03:38,730 --> 00:03:41,160
0, 1, 2, or 3.

83
00:03:41,160 --> 00:03:44,010
If we want to do a calculation,
for example, raising seven

84
00:03:44,010 --> 00:03:45,660
to the power of one of these numbers,

85
00:03:45,660 --> 00:03:48,480
we can only do it for one state at a time,

86
00:03:48,480 --> 00:03:50,220
in this case seven squared

87
00:03:50,220 --> 00:03:53,190
and so we get the answer 49.

88
00:03:53,190 --> 00:03:55,230
Quantum computers consist of qubits

89
00:03:55,230 --> 00:03:58,267
which also have two states, zero or one.

90
00:03:58,267 --> 00:04:01,020
But unlike a classical bit, a qubit,

91
00:04:01,020 --> 00:04:04,110
doesn't have to be in
just one state at a time.

92
00:04:04,110 --> 00:04:07,110
It can be in an arbitrary
combination of those states,

93
00:04:07,110 --> 00:04:10,920
a superposition if you
will, of zero and one.

94
00:04:10,920 --> 00:04:14,340
So if you have two qubits,
they can exist simultaneously

95
00:04:14,340 --> 00:04:19,340
in a superposition of 0, 1, 2, and 3.

96
00:04:20,550 --> 00:04:22,500
Now, when we repeat the same calculation,

97
00:04:22,500 --> 00:04:24,240
it will actually perform the calculation

98
00:04:24,240 --> 00:04:27,690
for all of those numbers at the same time.

99
00:04:27,690 --> 00:04:28,523
And what we're left

100
00:04:28,523 --> 00:04:31,500
with is a super position
of the different answers.

101
00:04:31,500 --> 00:04:35,430
1, 7, 49 and 343.

102
00:04:35,430 --> 00:04:37,080
If we add another qubit,

103
00:04:37,080 --> 00:04:39,780
we double the number of possible states.

104
00:04:39,780 --> 00:04:42,856
So with three qubits, we
can represent eight states,

105
00:04:42,856 --> 00:04:46,470
and thus perform eight
calculations all at once.

106
00:04:46,470 --> 00:04:48,840
Increase that number to just 20 qubits,

107
00:04:48,840 --> 00:04:50,280
and you can already represent

108
00:04:50,280 --> 00:04:52,354
over a million different states,

109
00:04:52,354 --> 00:04:54,900
meaning you can simultaneously compute

110
00:04:54,900 --> 00:04:57,510
over a million different answers.

111
00:04:57,510 --> 00:05:00,660
With 300 qubits, you can
represent more states

112
00:05:00,660 --> 00:05:04,131
than there are particles
in the observable universe.

113
00:05:04,131 --> 00:05:07,972
This sounds incredibly powerful and it is,

114
00:05:07,972 --> 00:05:11,010
but there is one very big catch.

115
00:05:11,010 --> 00:05:13,560
All of the answers to the
computation are embedded

116
00:05:13,560 --> 00:05:15,720
in a superposition of states,

117
00:05:15,720 --> 00:05:19,020
but you can't simply read
out this superposition.

118
00:05:19,020 --> 00:05:21,780
When you make a measurement,
you only get a single value

119
00:05:21,780 --> 00:05:24,360
from the superposition
basically at random,

120
00:05:24,360 --> 00:05:27,240
and all the other information is lost.

121
00:05:27,240 --> 00:05:30,480
So in order to harness the
power of a quantum computer,

122
00:05:30,480 --> 00:05:33,241
you need a smart way to convert
a superposition of states

123
00:05:33,241 --> 00:05:37,650
into one that contains only
the information you want.

124
00:05:37,650 --> 00:05:40,110
This is an incredibly difficult task,

125
00:05:40,110 --> 00:05:41,880
which is why for most applications,

126
00:05:41,880 --> 00:05:43,890
quantum computers are useless.

127
00:05:43,890 --> 00:05:46,260
So far, we've only
identified a few problems,

128
00:05:46,260 --> 00:05:49,290
where we can actually do this,
but as luck would have it,

129
00:05:49,290 --> 00:05:52,380
these are precisely the problems
that form the foundation

130
00:05:52,380 --> 00:05:55,803
of nearly all the public key
cryptography we use today.

131
00:05:56,670 --> 00:06:00,060
In 1994, Peter Shor and
Don Coppersmith figured out

132
00:06:00,060 --> 00:06:03,000
how to take a quantum Fourier transform.

133
00:06:03,000 --> 00:06:05,520
It works just like a
normal Fourier transform,

134
00:06:05,520 --> 00:06:07,380
apply it to some periodic signal,

135
00:06:07,380 --> 00:06:10,620
and it returns the frequencies
that are in that signal.

136
00:06:10,620 --> 00:06:12,840
Now this may not seem
particularly interesting

137
00:06:12,840 --> 00:06:14,236
but consider this.

138
00:06:14,236 --> 00:06:17,490
If we have a superposition
of states that is periodic,

139
00:06:17,490 --> 00:06:20,100
that is the terms in the
superposition are separated,

140
00:06:20,100 --> 00:06:22,020
by some regular amount,

141
00:06:22,020 --> 00:06:24,690
well we can apply the
quantum Fourier transform

142
00:06:24,690 --> 00:06:25,980
and will be left with states

143
00:06:25,980 --> 00:06:28,440
that contain the frequency of the signal.

144
00:06:28,440 --> 00:06:30,450
So this we can measure.

145
00:06:30,450 --> 00:06:32,160
The quantum Fourier transform,

146
00:06:32,160 --> 00:06:34,860
allows us to extract frequency information

147
00:06:34,860 --> 00:06:37,203
from a periodic superposition,

148
00:06:37,203 --> 00:06:39,603
and that is gonna come in handy.

149
00:06:41,010 --> 00:06:43,560
So how does a quantum
computer factor the product

150
00:06:43,560 --> 00:06:47,160
of two primes much faster
than a conventional computer?

151
00:06:47,160 --> 00:06:48,740
I want to explain this by first walking

152
00:06:48,740 --> 00:06:52,320
through a simple example with
no quantum computer required,

153
00:06:52,320 --> 00:06:54,660
and then I'll show how a quantum computer

154
00:06:54,660 --> 00:06:56,100
could execute this method

155
00:06:56,100 --> 00:07:00,270
even for a very large number
in a short period of time.

156
00:07:00,270 --> 00:07:02,550
So let's say we have a number N,

157
00:07:02,550 --> 00:07:06,000
which is the product
of two primes, p and q.

158
00:07:06,000 --> 00:07:10,110
For the sake of this example,
let's set N equal to 77.

159
00:07:10,110 --> 00:07:12,384
Now I bet you can guess the prime factors,

160
00:07:12,384 --> 00:07:15,180
but let's pretend for the
moment that we don't know them,

161
00:07:15,180 --> 00:07:18,273
because with a product of
really big primes, we wouldn't.

162
00:07:19,140 --> 00:07:21,270
Now I want to use a fact about numbers

163
00:07:21,270 --> 00:07:23,250
that feels like magic.

164
00:07:23,250 --> 00:07:27,103
Pick a number g that doesn't
share any factors with N.

165
00:07:27,103 --> 00:07:32,103
If you multiply g by itself
over and over and over,

166
00:07:32,610 --> 00:07:37,610
you will always eventually,
reach a multiple of N plus one.

167
00:07:38,010 --> 00:07:41,340
In other words, you can
always find some exponent r,

168
00:07:41,340 --> 00:07:46,230
such that g to the power of r,
is a multiple of N plus one.

169
00:07:46,230 --> 00:07:48,030
Let's see how this works.

170
00:07:48,030 --> 00:07:50,460
Pick any number that is smaller than 77.

171
00:07:50,460 --> 00:07:51,960
I'll pick the number eight.

172
00:07:51,960 --> 00:07:54,540
This number doesn't share factors with 77.

173
00:07:54,540 --> 00:07:56,550
And if you were doing
this with big primes,

174
00:07:56,550 --> 00:07:58,530
it would also be extremely unlikely

175
00:07:58,530 --> 00:07:59,940
that you just happen to pick a number

176
00:07:59,940 --> 00:08:02,080
that shares factors with N.

177
00:08:02,080 --> 00:08:06,600
Now multiply eight by itself
once, twice, three times

178
00:08:06,600 --> 00:08:10,271
four times, and so on, raising
eight to ever higher powers

179
00:08:10,271 --> 00:08:14,184
and then divide each
of these numbers by 77.

180
00:08:14,184 --> 00:08:16,680
We're not really interested
in how many times

181
00:08:16,680 --> 00:08:19,500
77 goes into the number,
just the remainder,

182
00:08:19,500 --> 00:08:22,140
what's left over, because at some point,

183
00:08:22,140 --> 00:08:24,240
77 should divide one of these numbers

184
00:08:24,240 --> 00:08:27,420
with a remainder of exactly one.

185
00:08:27,420 --> 00:08:30,835
So eight divided by 77 is
zero with a remainder of 8,

186
00:08:30,835 --> 00:08:34,871
64 divided by 77 is zero remainder 64.

187
00:08:34,871 --> 00:08:38,580
512 divided by 77 is six remainder 50.

188
00:08:38,580 --> 00:08:40,620
And as we keep going, we get remainders

189
00:08:40,620 --> 00:08:44,443
of 15, 43, 36, 57, 71,
29, and finally one.

190
00:08:49,551 --> 00:08:53,070
So there we have it,
eight to the power of 10

191
00:08:53,070 --> 00:08:56,010
is one more than a multiple of 77.

192
00:08:56,010 --> 00:09:00,720
So we've found the exponent R
that satisfies this equation.

193
00:09:00,720 --> 00:09:03,960
But how does this help
find the factors of N?

194
00:09:03,960 --> 00:09:05,910
Well, we rearrange the equation

195
00:09:05,910 --> 00:09:08,280
to bring one over to the left hand side,

196
00:09:08,280 --> 00:09:11,670
and then we can split it
into two terms like so.

197
00:09:11,670 --> 00:09:15,716
And now as long as r is
even, we have one integer

198
00:09:15,716 --> 00:09:20,640
times another integer is
equal to a multiple of N.

199
00:09:20,640 --> 00:09:25,320
This looks remarkably similar
to p times q equals N.

200
00:09:25,320 --> 00:09:27,120
I mean since we know that p and q

201
00:09:27,120 --> 00:09:28,980
are on the right hand
side of this equation,

202
00:09:28,980 --> 00:09:31,401
they must also be on the left hand side

203
00:09:31,401 --> 00:09:35,040
just multiplied by some
additional factors.

204
00:09:35,040 --> 00:09:36,360
So one way to think

205
00:09:36,360 --> 00:09:37,710
about what we've done is

206
00:09:37,710 --> 00:09:40,822
we've taken a bad guess
for one of the factors G,

207
00:09:40,822 --> 00:09:43,680
and by finding the exponent r,

208
00:09:43,680 --> 00:09:46,800
we've turned it into
two much better guesses

209
00:09:46,800 --> 00:09:50,247
that probably do share factors with N.

210
00:09:50,247 --> 00:09:52,860
Since r was 10, the two terms

211
00:09:52,860 --> 00:09:54,630
on the left hand side are eight

212
00:09:54,630 --> 00:09:58,600
to the power of five plus one, 32,769

213
00:09:58,600 --> 00:10:03,600
and eight to the power of
five minus one, 32,767.

214
00:10:04,200 --> 00:10:07,422
These two numbers probably
share factors with N.

215
00:10:07,422 --> 00:10:09,131
So how do we find them?

216
00:10:09,131 --> 00:10:11,853
We use Euclid's algorithm.

217
00:10:13,470 --> 00:10:15,480
If you wanna find the
greatest common divisor

218
00:10:15,480 --> 00:10:20,480
of two numbers, say 32,769 and 77,

219
00:10:20,520 --> 00:10:22,410
divide the bigger number
by the smaller one

220
00:10:22,410 --> 00:10:24,180
and record the remainder.

221
00:10:24,180 --> 00:10:29,180
In this case, 32,769 divided
by 77 gives a remainder of 44.

222
00:10:30,733 --> 00:10:34,650
Then shift the numbers one
position left and repeat.

223
00:10:34,650 --> 00:10:39,650
So now we divide 77 by 44
and we get a remainder of 33.

224
00:10:40,410 --> 00:10:41,760
Repeat the process again.

225
00:10:41,760 --> 00:10:45,120
44 divided by 33 gives a remainder of 11

226
00:10:45,120 --> 00:10:49,211
and again 33 divided by 11
equals three remainder zero.

227
00:10:49,211 --> 00:10:51,188
When the remainder is zero,

228
00:10:51,188 --> 00:10:54,030
the divisor is the greatest common factor

229
00:10:54,030 --> 00:10:56,180
between the two numbers you started with.

230
00:10:56,180 --> 00:10:58,020
In this case, it's 11,

231
00:10:58,020 --> 00:11:01,907
which is indeed a factor of 77 and 32,769.

232
00:11:03,459 --> 00:11:05,040
You could do the same procedure

233
00:11:05,040 --> 00:11:09,210
with the other number or just
divide 77 by 11 to get seven,

234
00:11:09,210 --> 00:11:11,490
its other prime factor.

235
00:11:11,490 --> 00:11:15,450
So to recap, if you wanna
find the prime factors p and q

236
00:11:15,450 --> 00:11:19,011
of a number N, first, make a bad guess, g,

237
00:11:19,011 --> 00:11:23,070
second, find out how many
times r you have to multiply g

238
00:11:23,070 --> 00:11:26,208
by itself to reach one
more than a multiple of N.

239
00:11:26,208 --> 00:11:28,950
Third, use that exponent to calculate

240
00:11:28,950 --> 00:11:32,218
two new numbers that probably
do share factors with N.

241
00:11:32,218 --> 00:11:34,740
And finally use Euclid's algorithm

242
00:11:34,740 --> 00:11:38,070
to find the shared factors
between those numbers and N,

243
00:11:38,070 --> 00:11:40,533
which should give you p and q.

244
00:11:41,400 --> 00:11:42,990
Now, you don't need a quantum computer

245
00:11:42,990 --> 00:11:46,440
to run any of these steps,
but on a classical computer,

246
00:11:46,440 --> 00:11:49,650
this method wouldn't be any
faster than other methods.

247
00:11:49,650 --> 00:11:51,930
The key process that a
quantum computer speeds up

248
00:11:51,930 --> 00:11:55,931
is step two, finding the
exponent you raise G2

249
00:11:55,931 --> 00:11:58,800
to equal one more than a multiple of N.

250
00:11:58,800 --> 00:12:01,620
To see why, let's go back to our example,

251
00:12:01,620 --> 00:12:03,780
where eight to the power of 10 is

252
00:12:03,780 --> 00:12:05,968
one more than a multiple of 77.

253
00:12:05,968 --> 00:12:08,100
Watch what happens to the remainders

254
00:12:08,100 --> 00:12:10,800
if we keep going past
eight to the power of 10,

255
00:12:10,800 --> 00:12:14,430
to 8 to the 11, eight
to the 12, and so on.

256
00:12:14,430 --> 00:12:19,243
Well, we get remainders
of 8, 64, 50, 15, 43, 36,

257
00:12:21,356 --> 00:12:23,523
57, 71, 29, and again one.

258
00:12:27,390 --> 00:12:32,390
The remainders cycle and
they will just keep cycling.

259
00:12:32,499 --> 00:12:35,040
Notice how the exponent
that yields a remainder

260
00:12:35,040 --> 00:12:38,387
of one is 20, which is 10
more than the first exponent

261
00:12:38,387 --> 00:12:40,800
that yielded a remainder of one.

262
00:12:40,800 --> 00:12:42,420
So we know that eight to the 30

263
00:12:42,420 --> 00:12:45,300
and eight to the 40, 8
raised to any power divisible

264
00:12:45,300 --> 00:12:49,860
by 10 will also be one
more than a multiple of 77.

265
00:12:49,860 --> 00:12:53,220
It's also worth noting that
if you pick any remainder

266
00:12:53,220 --> 00:12:56,748
say 15, the next time you
find that same remainder,

267
00:12:56,748 --> 00:13:00,300
the exponent will have increased by 10.

268
00:13:00,300 --> 00:13:02,970
So you can find the
exponent R that gets us

269
00:13:02,970 --> 00:13:04,860
to one more than a multiple of n,

270
00:13:04,860 --> 00:13:09,720
by looking at the spacing of
any remainder, not just one.

271
00:13:09,720 --> 00:13:11,370
Remember that.

272
00:13:11,370 --> 00:13:14,190
Here I'm plotting out the
remainders on a log scale

273
00:13:14,190 --> 00:13:17,760
so you can see they are
periodic with a period of 10.

274
00:13:17,760 --> 00:13:19,260
If I had made a different guess,

275
00:13:19,260 --> 00:13:22,076
say I had picked G equals
15 instead of eight,

276
00:13:22,076 --> 00:13:23,801
well then the period would be different

277
00:13:23,801 --> 00:13:26,160
and the remainders would be different

278
00:13:26,160 --> 00:13:29,463
but there would always
be a remainder of one.

279
00:13:30,420 --> 00:13:31,897
Why is this?

280
00:13:31,897 --> 00:13:35,036
Well, now that you can see
this is a repeating pattern,

281
00:13:35,036 --> 00:13:36,943
we can go back to the beginning

282
00:13:36,943 --> 00:13:41,943
and any number raised to
the power of zero is one.

283
00:13:42,060 --> 00:13:44,940
So that is actually the first remainder.

284
00:13:44,940 --> 00:13:47,943
So it must also appear when
the cycle starts again.

285
00:13:49,110 --> 00:13:51,300
Now we are ready to use a quantum computer

286
00:13:51,300 --> 00:13:54,420
to factor any large product of two primes.

287
00:13:54,420 --> 00:13:57,870
First we split up the
qubits into two sets.

288
00:13:57,870 --> 00:14:00,840
The first set we prepare
in a superposition of zero

289
00:14:00,840 --> 00:14:03,090
and one and two and three

290
00:14:03,090 --> 00:14:05,340
and four and five and six
and seven and eight and nine,

291
00:14:05,340 --> 00:14:10,340
all the way up to 10
to the power of 1,234.

292
00:14:10,530 --> 00:14:14,070
Yeah, this is a huge superposition,

293
00:14:14,070 --> 00:14:16,050
but if we had perfect qubits,

294
00:14:16,050 --> 00:14:19,980
it would require only around 4,100.

295
00:14:19,980 --> 00:14:22,920
The other set contains a
similar number of qubits

296
00:14:22,920 --> 00:14:25,950
all left in the zero state for now.

297
00:14:25,950 --> 00:14:28,050
Now we make our guess G,

298
00:14:28,050 --> 00:14:31,260
which most likely doesn't
share factors with N.

299
00:14:31,260 --> 00:14:35,100
We raise G to the power
of the first set of qubits

300
00:14:35,100 --> 00:14:36,990
and then we divide by N

301
00:14:36,990 --> 00:14:40,530
and store the remainder in
the second set of qubits

302
00:14:40,530 --> 00:14:43,770
leaving the first set of qubits as it was.

303
00:14:43,770 --> 00:14:46,470
Now we have a superposition
of all the numbers

304
00:14:46,470 --> 00:14:49,890
we started with and the
remainder of raising G

305
00:14:49,890 --> 00:14:52,920
to the power of those
numbers divided by N.

306
00:14:52,920 --> 00:14:54,600
And through this operation,

307
00:14:54,600 --> 00:14:58,274
we have entangled our two sets of qubits,

308
00:14:58,274 --> 00:15:01,047
but we can't just measure
this superposition.

309
00:15:01,047 --> 00:15:04,830
If we did, we would get a
random value and learn nothing.

310
00:15:04,830 --> 00:15:06,840
But there is a trick we can use.

311
00:15:06,840 --> 00:15:09,420
If we don't measure the
entire superposition,

312
00:15:09,420 --> 00:15:11,430
but only the remainder part,

313
00:15:11,430 --> 00:15:14,490
we will obtain some random remainder.

314
00:15:14,490 --> 00:15:17,580
But this remainder won't occur just once.

315
00:15:17,580 --> 00:15:19,366
It will occur multiple times

316
00:15:19,366 --> 00:15:22,560
every time it comes up in the cycle.

317
00:15:22,560 --> 00:15:24,540
Imagine we were doing
this with the example

318
00:15:24,540 --> 00:15:27,948
from before with N equals
77 and G equals eight.

319
00:15:27,948 --> 00:15:31,279
If the remainder we measured was say 15,

320
00:15:31,279 --> 00:15:34,830
then there would be multiple
terms in our superposition.

321
00:15:34,830 --> 00:15:36,660
Because there are multiple exponents

322
00:15:36,660 --> 00:15:39,750
you can raise G2 that
give this same remainder,

323
00:15:39,750 --> 00:15:44,580
exponents 4, 14, 24, 34, and so on.

324
00:15:44,580 --> 00:15:46,971
They are each separated by 10,

325
00:15:46,971 --> 00:15:51,971
and that value is the exponent
that satisfies our equation.

326
00:15:52,260 --> 00:15:55,380
So more generally after
measuring the remainder,

327
00:15:55,380 --> 00:15:57,390
we will be left with a
superposition of states

328
00:15:57,390 --> 00:15:59,310
that all share the same remainder

329
00:15:59,310 --> 00:16:01,230
and the exponents will all be separated

330
00:16:01,230 --> 00:16:03,450
by the same amount r.

331
00:16:03,450 --> 00:16:06,720
This is the number we are looking for.

332
00:16:06,720 --> 00:16:09,660
Since the remainder is now
the same for all states,

333
00:16:09,660 --> 00:16:11,053
we can put it to the side

334
00:16:11,053 --> 00:16:14,610
and we now have a
superposition that is periodic.

335
00:16:14,610 --> 00:16:18,480
Each term is separated from
its neighbors by an amount R.

336
00:16:18,480 --> 00:16:20,730
If we now apply the
quantum Fourier transform

337
00:16:20,730 --> 00:16:22,470
to this superposition of states

338
00:16:22,470 --> 00:16:24,480
and I'm simplifying a little here,

339
00:16:24,480 --> 00:16:28,230
we will be left with states
containing one over R.

340
00:16:28,230 --> 00:16:29,430
So all that's left to do now

341
00:16:29,430 --> 00:16:33,450
is perform a measurement
and find R by inverting it,

342
00:16:33,450 --> 00:16:35,200
and that's it for the quantum part.

343
00:16:36,420 --> 00:16:38,610
Now, as long as r turns out to be even

344
00:16:38,610 --> 00:16:40,920
we can use r to turn our bad guess g

345
00:16:40,920 --> 00:16:44,190
into two numbers that
likely share factors with N.

346
00:16:44,190 --> 00:16:45,990
And as long as these terms themselves

347
00:16:45,990 --> 00:16:47,190
are not a multiple of N,

348
00:16:47,190 --> 00:16:49,764
we can use Euclid's algorithm
to find the factors of N

349
00:16:49,764 --> 00:16:51,719
and break the encryption.

350
00:16:51,719 --> 00:16:55,650
This would only take several
thousand perfect qubits,

351
00:16:55,650 --> 00:16:58,140
but the qubits we have
today are imperfect,

352
00:16:58,140 --> 00:16:59,670
so we need additional qubits

353
00:16:59,670 --> 00:17:02,100
to act as redundant information.

354
00:17:02,100 --> 00:17:04,079
In 2012, it was estimated

355
00:17:04,079 --> 00:17:06,479
that it would take a
billion physical qubits

356
00:17:06,480 --> 00:17:08,165
to break RSA encryption,

357
00:17:08,165 --> 00:17:10,349
but by five years later that number

358
00:17:10,349 --> 00:17:12,629
had dropped to 230 million.

359
00:17:12,630 --> 00:17:15,490
And in 2019, after more
technological breakthroughs,

360
00:17:15,490 --> 00:17:20,430
that estimate plummeted to just 20 million physical qubits.

361
00:17:20,430 --> 00:17:23,220
So how many qubits do we have today?

362
00:17:23,220 --> 00:17:26,277
Well, if we look at the state
of IBM's quantum computers,

363
00:17:26,277 --> 00:17:29,850
we are nowhere near that number of qubits,

364
00:17:29,850 --> 00:17:32,640
but progress looks to be exponential.

365
00:17:32,640 --> 00:17:34,200
So now it's just a question

366
00:17:34,200 --> 00:17:36,090
of when these two curves will collide

367
00:17:36,090 --> 00:17:40,863
before all our existing public
key encryption can be broken.

368
00:17:42,570 --> 00:17:45,030
Because we've long known
this threat is coming,

369
00:17:45,030 --> 00:17:47,790
scientists have been looking
for new ways to encrypt data,

370
00:17:47,790 --> 00:17:49,020
which can withstand attacks

371
00:17:49,020 --> 00:17:51,840
from both normal and quantum computers.

372
00:17:51,840 --> 00:17:54,900
In 2016, the National Institute
of Standards and Technology

373
00:17:54,900 --> 00:17:56,414
or NIST, launched a competition

374
00:17:56,414 --> 00:17:58,650
to find new encryption algorithms

375
00:17:58,650 --> 00:18:00,990
that aren't vulnerable
to quantum computers.

376
00:18:00,990 --> 00:18:02,640
Cryptographers from all over the world

377
00:18:02,640 --> 00:18:04,800
submitted 82 different proposals,

378
00:18:04,800 --> 00:18:07,770
which were rigorously
tested, some were broken.

379
00:18:07,770 --> 00:18:09,810
And then on July 5th, 2022,

380
00:18:09,810 --> 00:18:12,020
NIST selected four of
the algorithms to be part

381
00:18:12,020 --> 00:18:15,360
of their post-quantum
cryptographic standard.

382
00:18:15,360 --> 00:18:17,370
So how do they work?

383
00:18:17,370 --> 00:18:19,110
Well, three of the algorithms are based

384
00:18:19,110 --> 00:18:21,000
on the mathematics of latices.

385
00:18:21,000 --> 00:18:24,842
So let's do a simple
example in the 2D plane.

386
00:18:24,842 --> 00:18:29,310
Take two vectors, r1 and
r2, by adding together

387
00:18:29,310 --> 00:18:30,780
different integer combinations

388
00:18:30,780 --> 00:18:34,710
of these vectors, say three
times r1 and one times r2,

389
00:18:34,710 --> 00:18:36,821
you can get two different points

390
00:18:36,821 --> 00:18:38,370
and all the points you can get

391
00:18:38,370 --> 00:18:39,780
to by combining these two vectors

392
00:18:39,780 --> 00:18:42,686
in different ways is
what is called a lattice.

393
00:18:42,686 --> 00:18:45,840
Now I will also give you the point C,

394
00:18:45,840 --> 00:18:49,087
and your task is to tell me
which combination of r1 and r2

395
00:18:49,087 --> 00:18:53,100
will bring me to the
lattice point closest to c.

396
00:18:53,100 --> 00:18:55,080
It's pretty easy to see
that we can get there

397
00:18:55,080 --> 00:18:57,420
by going in the direction of r2 twice

398
00:18:57,420 --> 00:19:00,210
and in the negative direction of r1 twice.

399
00:19:00,210 --> 00:19:01,710
Simple enough.

400
00:19:01,710 --> 00:19:04,470
But those vectors, r1 and r2 are not

401
00:19:04,470 --> 00:19:07,290
the only vectors that can
give you this lattice.

402
00:19:07,290 --> 00:19:10,380
Take b1 and b2 for example.

403
00:19:10,380 --> 00:19:13,470
These vectors also build
up the same lattice.

404
00:19:13,470 --> 00:19:15,690
And now if I ask you
the same question again,

405
00:19:15,690 --> 00:19:18,510
can you tell me the
combination of b1 and b2

406
00:19:18,510 --> 00:19:21,720
that gets you to the
lattice point closest to c?

407
00:19:21,720 --> 00:19:25,442
This has become a lot
harder, but why is that?

408
00:19:25,442 --> 00:19:28,620
Each time we're taking a step,
we're trying to get closer

409
00:19:28,620 --> 00:19:32,610
in either the X or Y direction,
but with the b vectors,

410
00:19:32,610 --> 00:19:34,410
each time we take a step
in the right direction

411
00:19:34,410 --> 00:19:38,160
with one vector, it puts us
off in the other direction.

412
00:19:38,160 --> 00:19:41,520
And that's why these vectors
are a lot harder to work with.

413
00:19:41,520 --> 00:19:43,620
In the end, it takes us a combination

414
00:19:43,620 --> 00:19:47,310
of eight times b1 and
negative six times b2

415
00:19:47,310 --> 00:19:49,680
to get to the closest lattice point.

416
00:19:49,680 --> 00:19:52,140
That is a lot harder than before,

417
00:19:52,140 --> 00:19:55,260
but it's still a relatively
easy problem to solve.

418
00:19:55,260 --> 00:19:57,330
But if we extend it to three dimensions,

419
00:19:57,330 --> 00:19:59,760
this already becomes a lot harder,

420
00:19:59,760 --> 00:20:02,100
especially because you're
not given the collection

421
00:20:02,100 --> 00:20:03,540
of all lattice points.

422
00:20:03,540 --> 00:20:05,700
You're only given the
vectors that make it up.

423
00:20:05,700 --> 00:20:08,340
So when you find a lattice
point close to the target,

424
00:20:08,340 --> 00:20:10,830
you must still find all the
other lattice points near it

425
00:20:10,830 --> 00:20:14,040
to make sure yours is indeed the closest.

426
00:20:14,040 --> 00:20:16,980
Let's take a circle of
radius r in two dimensions.

427
00:20:16,980 --> 00:20:19,080
The number of lattice
points inside the circle

428
00:20:19,080 --> 00:20:21,480
is proportional to r squared.

429
00:20:21,480 --> 00:20:23,460
Add a third dimension
and the number of points

430
00:20:23,460 --> 00:20:26,490
in the sphere is proportional to r cubed.

431
00:20:26,490 --> 00:20:29,700
So just watch how the number
of lattice points grows

432
00:20:29,700 --> 00:20:32,583
as we increase the number of dimensions.

433
00:20:34,050 --> 00:20:35,850
Solving the closest vector problem

434
00:20:35,850 --> 00:20:38,670
is a piece of cake for your
computer in three dimensions.

435
00:20:38,670 --> 00:20:41,390
Even a hundred dimensions
should be manageable.

436
00:20:41,390 --> 00:20:44,280
But in proposed future encryption schemes,

437
00:20:44,280 --> 00:20:47,370
we'll use around a thousand dimensions.

438
00:20:47,370 --> 00:20:48,900
Take one step in the right direction

439
00:20:48,900 --> 00:20:51,990
on one of those dimensions,
and you could potentially

440
00:20:51,990 --> 00:20:56,640
be taking a wrong step in
the other 999 dimensions.

441
00:20:56,640 --> 00:21:00,390
You win some, you lose everything else.

442
00:21:00,390 --> 00:21:01,440
With that many dimensions,

443
00:21:01,440 --> 00:21:04,290
it becomes extremely hard
to find the closest point

444
00:21:04,290 --> 00:21:06,368
even for the most powerful computers,

445
00:21:06,368 --> 00:21:10,281
that is unless you know
a good set of vectors.

446
00:21:10,281 --> 00:21:13,440
So how do we use that to encrypt data?

447
00:21:13,440 --> 00:21:16,410
Well, let's go back to our
two-dimensional example.

448
00:21:16,410 --> 00:21:18,300
Each person has a good set of vectors

449
00:21:18,300 --> 00:21:19,920
that describes a lattice,

450
00:21:19,920 --> 00:21:22,110
but they keep these vectors secret,

451
00:21:22,110 --> 00:21:24,360
and they only share their lattice publicly

452
00:21:24,360 --> 00:21:27,690
using a set of vectors
that is hard to work with.

453
00:21:27,690 --> 00:21:29,513
Now, if I want to send someone a message,

454
00:21:29,513 --> 00:21:32,487
I pick a point on their
lattice, for example,

455
00:21:32,487 --> 00:21:35,550
say this point corresponds
to the number seven.

456
00:21:35,550 --> 00:21:39,210
So if I wanna send the number
seven, I can take that point

457
00:21:39,210 --> 00:21:42,060
but then add some random noise to it.

458
00:21:42,060 --> 00:21:44,142
So the message I send is not precisely

459
00:21:44,142 --> 00:21:47,178
at that point but close to it.

460
00:21:47,178 --> 00:21:50,340
Now, to decode the message,
my recipient must figure out

461
00:21:50,340 --> 00:21:53,020
which lattice point is
closest to the message point.

462
00:21:53,020 --> 00:21:55,050
In a thousand dimensions,

463
00:21:55,050 --> 00:21:57,252
this will be extremely hard to do

464
00:21:57,252 --> 00:22:00,540
unless you have the nice set of vectors,

465
00:22:00,540 --> 00:22:02,250
which my recipient does.

466
00:22:02,250 --> 00:22:04,440
So it's easy for the recipient,

467
00:22:04,440 --> 00:22:07,672
who has the good vectors,
but hard for everyone else.

468
00:22:07,672 --> 00:22:11,130
And as far as we know,
this problem is extremely

469
00:22:11,130 --> 00:22:15,630
difficult to solve for both
normal and quantum computers.

470
00:22:15,630 --> 00:22:18,390
Behind the scenes, there's
an army of researchers,

471
00:22:18,390 --> 00:22:20,220
mathematicians, and cryptographers,

472
00:22:20,220 --> 00:22:23,550
we're gonna make sure your
secret data stays secret.

473
00:22:23,550 --> 00:22:25,320
These are some of the unsung heroes

474
00:22:25,320 --> 00:22:27,270
that will keep us safe moving forward,

475
00:22:27,270 --> 00:22:29,370
avoiding mass surveillance by governments

476
00:22:29,370 --> 00:22:31,530
keeping critical infrastructure protected

477
00:22:31,530 --> 00:22:34,590
and allowing you to live
as if quantum computers

478
00:22:34,590 --> 00:22:37,664
were never invented in the first place.

479
00:22:37,664 --> 00:22:40,497
(digital buzzing)

480
00:22:43,260 --> 00:22:45,510
Something that fascinates me is being able

481
00:22:45,510 --> 00:22:47,580
to see where the world is headed.

482
00:22:47,580 --> 00:22:49,830
And right now it's clear
that quantum computers

483
00:22:49,830 --> 00:22:53,010
and AI chatbots are going to
play bigger and bigger roles

484
00:22:53,010 --> 00:22:54,709
in our lives in the coming decades.

485
00:22:54,709 --> 00:22:58,290
Even if we don't know exactly
how they'll be implemented,

486
00:22:58,290 --> 00:23:01,440
I think it's important to
learn how they work right now

487
00:23:01,440 --> 00:23:04,680
and you can do that with this
video's sponsor, Brilliant.

488
00:23:04,680 --> 00:23:06,510
Brilliant has an incredible course

489
00:23:06,510 --> 00:23:08,190
on quantum algorithms.

490
00:23:08,190 --> 00:23:11,328
This one was co-developed
with Microsoft and Alphabet X.

491
00:23:11,328 --> 00:23:14,250
I love that you can simulate
quantum gates and write

492
00:23:14,250 --> 00:23:17,430
and execute real quantum
algorithms right in the lesson.

493
00:23:17,430 --> 00:23:20,100
No need to set up your own
development environment.

494
00:23:20,100 --> 00:23:22,590
And if you want to dive
deeper into cryptography,

495
00:23:22,590 --> 00:23:26,430
making and breaking codes is
really a matter of statistics.

496
00:23:26,430 --> 00:23:28,170
Strong statistical reasoning skills

497
00:23:28,170 --> 00:23:29,700
help us find patterns in data

498
00:23:29,700 --> 00:23:30,900
and make sense of them,

499
00:23:30,900 --> 00:23:32,310
which is crucial to mastering

500
00:23:32,310 --> 00:23:34,050
just about any topic in math

501
00:23:34,050 --> 00:23:35,430
and computer Science.

502
00:23:35,430 --> 00:23:37,170
Brilliant's course on data analysis

503
00:23:37,170 --> 00:23:39,150
will help you ramp up fast.

504
00:23:39,150 --> 00:23:40,800
It uses everyday situations,

505
00:23:40,800 --> 00:23:43,410
like business models to
illustrate key concepts

506
00:23:43,410 --> 00:23:45,779
in statistics and it's interactive,

507
00:23:45,779 --> 00:23:48,990
so you can get hands on
with data visualizations

508
00:23:48,990 --> 00:23:52,200
and develop a real intuition
for interpreting them.

509
00:23:52,200 --> 00:23:54,120
You know the thing that
sets Brilliant apart

510
00:23:54,120 --> 00:23:56,010
is they know how to
break fundamentals down

511
00:23:56,010 --> 00:23:57,840
into their core building blocks,

512
00:23:57,840 --> 00:23:59,700
whether you're learning
math, computer science

513
00:23:59,700 --> 00:24:01,530
or data analysis, Brilliant's

514
00:24:01,530 --> 00:24:03,960
thousands of bite-sized
interactive lessons

515
00:24:03,960 --> 00:24:05,550
help you master key concepts

516
00:24:05,550 --> 00:24:07,950
and build to more advanced topics.

517
00:24:07,950 --> 00:24:09,900
You can try everything
Brilliant has to offer

518
00:24:09,900 --> 00:24:11,610
for free for a full 30 days.

519
00:24:11,610 --> 00:24:14,610
Just go to brilliant.org/veritasium.

520
00:24:14,610 --> 00:24:16,920
I will put that link
down in the description.

521
00:24:16,920 --> 00:24:19,290
And for viewers of this
video, Brilliant is offering

522
00:24:19,290 --> 00:24:21,480
20% off their annual premium subscription

523
00:24:21,480 --> 00:24:23,310
to the first 200 people to sign up.

524
00:24:23,310 --> 00:24:26,010
So I wanna thank Brilliant
for sponsoring this video,

525
00:24:26,010 --> 00:24:27,873
and I want to thank you for watching.

