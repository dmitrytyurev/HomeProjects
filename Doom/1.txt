
	OutputDebugStringA("\npalce 1\n");
//================================================================================

	int bufSizeX = 320;
	int bufSizeY = 200;
	double horizontalAngle = 90.0 / 180.0 * 3.14159265359;

	double dz = 1.0 / tan(horizontalAngle / 2.0);

	for (int x = 0; x < bufSizeX; ++x) {
		double curX = (x - bufSizeX / 2 + 0.5) * 2.0 / bufSizeX;
		double curAngle = atan(curX / dz);
		printf("curAngle: %f\n", curAngle / 3.14159265359 * 180.0);
	}

//================================================================================

	double curAngle = 3.14159;
	double x1 = 100;
	double y1 = 200;
	double co = cos(-curAngle);
	double si = sin(-curAngle);
	double x2 = x1 * co + y1 * si;
	double y2 = -x1 * si + y1 * co;

//================================================================================

Вх:   y,z
Вых:  yScr =  (-y / z) * bufSizeY / 2 + bufSizeY / 2;

	double kProj = bufSizeX / 2 / tan(horizontalAngle / 2);
	double yScr = (-y / z) * kProj + bufSizeY / 2;


//================================================================================
 Перспективная коррекция текстурных координат:  Линейно интерполируем: U1/z, U2/z, 1/z.  

//================================================================================

- Для всех вершин полигона заполнить массив флагов: xn<0
- Отрезок не рассматриваем, если
  - флаги его вершин не равны
  - Через этот отрезок пришли из предыдущего полигона
- Если отрезков не осталось: error
- Для оставшихся отрезков найти пересечения
- Из пересечений выбрать с Макс z
- Если z < 0.001, то перейти к отрисовке следующего отрезка


